"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[463],{4534:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"blockchain-1","metadata":{"permalink":"/Learning/blog/blockchain-1","editUrl":"https://github.com/robertovicario/Learning/tree/main/app/blog/blockchain/1.md","source":"@site/blog/blockchain/1.md","title":"Introduction to Blockchain","description":"A simple implementation of a blockchain in Python","date":"2025-04-20T11:12:41.000Z","tags":[{"inline":true,"label":"computer-science","permalink":"/Learning/blog/tags/computer-science"},{"inline":true,"label":"blockchain","permalink":"/Learning/blog/tags/blockchain"},{"inline":true,"label":"cybersecurity","permalink":"/Learning/blog/tags/cybersecurity"},{"inline":true,"label":"cryptography","permalink":"/Learning/blog/tags/cryptography"},{"inline":true,"label":"python","permalink":"/Learning/blog/tags/python"}],"readingTime":5.055,"hasTruncateMarker":false,"authors":[{"name":"Roberto Vicario","title":"Software Engineer","url":"https://github.com/robertovicario","image_url":"https://github.com/robertovicario.png","socials":{"website":"https://www.robertovicario.com","instagram":"https://www.instagram.com/robertovicario__","linkedin":"https://www.linkedin.com/in/robertovicario/","github":"https://github.com/robertovicario"},"imageURL":"https://github.com/robertovicario.png","key":null,"page":null}],"frontMatter":{"title":"Introduction to Blockchain","description":"A simple implementation of a blockchain in Python","slug":"blockchain-1","authors":[{"name":"Roberto Vicario","title":"Software Engineer","url":"https://github.com/robertovicario","image_url":"https://github.com/robertovicario.png","socials":{"website":"https://www.robertovicario.com","instagram":"robertovicario__","linkedin":"robertovicario","github":"robertovicario"},"imageURL":"https://github.com/robertovicario.png"}],"tags":["computer-science","blockchain","cybersecurity","cryptography","python"]},"unlisted":false},"content":"---\\n\\n### \ud83d\udcd6 Lecture\\n\\nPlayground linked with the lecture [Blockchain: Introduction](/docs/blockchain/1).\\n\\n---\\n\\n## \u2699\ufe0f Implementation\\n\\nIn this playground, we will implement a simple blockchain in Python. The goal is to understand the basic concepts of blockchain technology, including **blocks**, **transactions**, and the **chain** itself.\\n\\n### \ud83d\udce6 Dependencies\\n\\nTo get started, we need to import the following dependencies:\\n\\n```py\\nfrom time import localtime, strftime\\nfrom typing import List\\nimport hashlib\\nimport json\\n```\\n\\n### \ud83d\udcb8 Transactions\\n\\nTo create a `Transaction` class to represent a transaction between two parties. Each transaction will include a **sender**, a **receiver**, and an **amount**:\\n\\n```py\\nclass Transaction:\\n    def __init__(self, sender: str, receiver: str, amount: float):\\n        self.sender = sender\\n        self.receiver = receiver\\n        self.amount = amount\\n\\n    def __repr__(self):\\n        return f\'{self.sender} -> {self.receiver}: {self.amount}\'\\n```\\n\\n### \ud83e\uddf1 Blocks\\n\\nNext, we will create a `Block` class to represent a block in the blockchain. Each block will contain a **list of transactions**, a **timestamp**, and a **hash of the previous block**. In this case, the hash is calculated using the _SHA-256_ algorithm:\\n\\n```py\\nclass Block:\\n    def __init__(self, transactions: List[Transaction], previous_hash: str):\\n        self.timestamp = strftime(\'%Y-%m-%d %H:%M:%S\', localtime())\\n        self.transactions = transactions\\n        self.previous_hash = previous_hash\\n        self.hash = self.calculate_hash()\\n\\n    def calculate_hash(self):\\n        tx_str = \'\'.join(str(tx) for tx in self.transactions)\\n        block_string = f\'{self.timestamp}{tx_str}{self.previous_hash}\'\\n        return hashlib.sha256(block_string.encode()).hexdigest()\\n\\n    def __repr__(self):\\n        return json.dumps({\\n            \'hash\': self.hash,\\n            \'previous_hash\': self.previous_hash,\\n            \'transactions\': [str(tx) for tx in self.transactions],\\n            \'timestamp\': self.timestamp\\n        }, indent=4)\\n```\\n\\n### \u26d3\ufe0f Blockchain\\n\\nFinally, we will create a `Blockchain` class to represent the entire blockchain. This class will manage the **list of blocks** and the **pending transactions**. It will also include methods to **add transactions**, **mine new blocks**, and **validate the chain**:\\n\\n```py\\nclass Blockchain:\\n    def __init__(self):\\n        self.chain: List[Block] = [self.create_genesis_block()]\\n        self.pending_transactions: List[Transaction] = []\\n\\n    def create_genesis_block(self):\\n        return Block(transactions=[], previous_hash=\'0\')\\n\\n    def get_latest_block(self):\\n        return self.chain[-1]\\n\\n    def add_transaction(self, transaction: Transaction):\\n        self.pending_transactions.append(transaction)\\n\\n    def mine_block(self):\\n        if not self.pending_transactions:\\n            return None\\n\\n        new_block = Block(\\n            transactions=self.pending_transactions,\\n            previous_hash=self.get_latest_block().hash\\n        )\\n        self.chain.append(new_block)\\n        self.pending_transactions = []\\n        return new_block\\n\\n    def is_chain_valid(self):\\n        for i in range(1, len(self.chain)):\\n            curr = self.chain[i]\\n            prev = self.chain[i - 1]\\n            if curr.hash != curr.calculate_hash():\\n                return False\\n            if curr.previous_hash != prev.hash:\\n                return False\\n        return True\\n\\n    def __repr__(self):\\n        return \'\\\\n\'.join(str(block) for block in self.chain)\\n```\\n\\n---\\n\\n## \ud83d\ude80 Let\'s Play\\n\\nNow that we have implemented the basic components of a blockchain, let\'s explore how to use them in practice.\\n\\n### \u26d3\ufe0f Creating a Blockchain\\n\\nWe start by creating an instance of the `Blockchain` class:\\n\\n```py\\nblockchain = Blockchain()\\nprint(f\\"Blockchain: {blockchain}\\")\\n```\\n\\nAt the beginning, the blockchain contains only the **genesis block**:\\n\\n```out\\nBlockchain: {\\n    \\"hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"previous_hash\\": \\"0\\",\\n    \\"transactions\\": [],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n```\\n\\n:::info Genesis Block\\nThe **genesis block** is the first block in a blockchain and serves as the foundation of the chain. It is **unique** because it has no previous block, and its `previous_hash` is set to `0`. This block is crucial for establishing the **integrity** and **immutability** of the blockchain.\\n:::\\n\\n### \ud83d\udcb8 Adding Transactions\\n\\nNow, let\'s add a first transaction of `50` units from `Alice` to `Eve` and mine a new block:\\n\\n```py\\nblockchain.add_transaction(Transaction(\'Alice\', \'Eve\', 50))\\nmined_block = blockchain.mine_block()\\nprint(f\\"Blockchain: {blockchain}\\")\\nprint(\'\\\\n# -------------------------\\\\n\')\\nprint(f\\"Mined Block 1: {mined_block}\\")\\n```\\n\\nThe `mine_block` method creates a new block with the **pending transactions** and adds it to the blockchain. The `previous_hash` of the new block is set to the **hash of the latest block** in the chain:\\n\\n```out\\nBlockchain: {\\n    \\"hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"previous_hash\\": \\"0\\",\\n    \\"transactions\\": [],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n{\\n    \\"hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"previous_hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"transactions\\": [\\n        \\"Alice -> Eve: 50\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n\\n# -------------------------\\n\\nMined Block 1: {\\n    \\"hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"previous_hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"transactions\\": [\\n        \\"Alice -> Eve: 50\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n```\\n\\n:::info Mining\\nThe process of creating a new block and adding it to the blockchain is called **mining**. In a real-world blockchain, this process involves solving complex **mathematical problems** to validate transactions and secure the network.\\n:::\\n\\n---\\n\\nNext, let\'s add another transaction of `50` units from `Bob` to `Alice` and mine a second block:\\n\\n```py\\nblockchain.add_transaction(Transaction(\'Bob\', \'Alice\', 50))\\nmined_block = blockchain.mine_block()\\nprint(f\\"Blockchain: {blockchain}\\")\\nprint(\'\\\\n# -------------------------\\\\n\')\\nprint(f\\"Mined Block 2: {mined_block}\\")\\n```\\n\\nThe second block is created in the **same way** as the first one, with the `previous_hash` set to the hash of the first block:\\n\\n```out\\nBlockchain: {\\n    \\"hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"previous_hash\\": \\"0\\",\\n    \\"transactions\\": [],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n{\\n    \\"hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"previous_hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"transactions\\": [\\n        \\"Alice -> Eve: 50\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n{\\n    \\"hash\\": \\"25eebad25dc8b2e46b9b2329f58080dd9900e0b1db63ff4ff5427806ce50c1e4\\",\\n    \\"previous_hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"transactions\\": [\\n        \\"Bob -> Alice: 50\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n\\n# -------------------------\\n\\nMined Block 2: {\\n    \\"hash\\": \\"25eebad25dc8b2e46b9b2329f58080dd9900e0b1db63ff4ff5427806ce50c1e4\\",\\n    \\"previous_hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"transactions\\": [\\n        \\"Bob -> Alice: 50\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n```\\n\\n### \ud83d\udd25 Chain Validation\\n\\nNow, let\'s explore what happens if someone tries to **tamper** with the blockchain:\\n\\n```py\\nprint(f\\"Validity: {blockchain.is_chain_valid()}\\")\\nprint(\'\\\\n# -------------------------\\\\n\')\\n\\n# -------------------------\\n\\nblockchain.chain[1].transactions[0].amount = 1000\\nprint(f\\"Tampered Block 1: {blockchain.chain[1]}\\")\\n\\n# -------------------------\\n\\nprint(\'\\\\n# -------------------------\\\\n\')\\nprint(f\\"Validity: {blockchain.is_chain_valid()}\\")\\n```\\n\\n:::danger Tampering\\nEve is trying to cheat by changing the amount of the first transaction from `50` to `1000`.\\n:::\\n\\nThe `is_chain_valid` method will check if the hash of the tampered block **matches** the calculated hash. If it doesn\'t, it will return `False`, indicating that the chain is invalid:\\n\\n```out\\nValidity: True\\n\\n# -------------------------\\n\\nTampered Block 1: {\\n    \\"hash\\": \\"8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389\\",\\n    \\"previous_hash\\": \\"3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0\\",\\n    \\"transactions\\": [\\n        \\"Alice -> Eve: 1000\\"\\n    ],\\n    \\"timestamp\\": \\"2025-04-20 11:24:45\\"\\n}\\n\\n# -------------------------\\n\\nValidity: False\\n```\\n\\nThis last example demonstrates how the blockchain\'s integrity is maintained through **cryptographic hashing**. If any block in the chain is tampered with, the hash of that block will change, causing the `is_chain_valid` method to return `False`. This ensures that the blockchain remains secure and **tamper-proof**.\\n\\n:::tip Consensus\\nIn a real-world blockchain, the **consensus mechanism** (like _Proof of Work_ or _Proof of Stake_) is used to ensure that all nodes in the network **agree on the state** of the blockchain. This prevents malicious actors from tampering with the chain and ensures that all transactions are valid.\\n:::\\n\\n---\\n\\n## \ud83c\udfaf Conclusion\\n\\nIn this playground, we have implemented a simple blockchain in Python. We created classes for **transactions**, **blocks**, and the **blockchain** itself. We also demonstrated how to add transactions, mine new blocks, and validate the chain."}]}}')}}]);