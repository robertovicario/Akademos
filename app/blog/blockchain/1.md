---
title: Introduction to Blockchain
description: A simple implementation of a blockchain in Python
slug: blockchain-1
authors:
    - name: Roberto Vicario
      title: Software Engineer
      url: https://github.com/robertovicario
      image_url: https://github.com/robertovicario.png
      socials:
        website: https://www.robertovicario.com
        instagram: robertovicario__
        linkedin: robertovicario
        github: robertovicario
tags:
    - computer-science
    - blockchain
    - cybersecurity
    - cryptography
    - python
---

# Introduction

---

### 📖 Lecture

Playground linked with the lecture [Blockchain: Introduction](/docs/blockchain/1).

---

## ⚙️ Implementation

In this playground, we will implement a simple blockchain in Python. The goal is to understand the basic concepts of blockchain technology, including **blocks**, **transactions**, and the **chain** itself.

### 📦 Dependencies

To get started, we need to import the following dependencies:

```py
from time import localtime, strftime
from typing import List
import hashlib
import json
```

### 💸 Transactions

To create a `Transaction` class to represent a transaction between two parties. Each transaction will include a **sender**, a **receiver**, and an **amount**:

```py
class Transaction:
    def __init__(self, sender: str, receiver: str, amount: float):
        self.sender = sender
        self.receiver = receiver
        self.amount = amount

    def __repr__(self):
        return f'{self.sender} -> {self.receiver}: {self.amount}'
```

### 🧱 Blocks

Next, we will create a `Block` class to represent a block in the blockchain. Each block will contain a **list of transactions**, a **timestamp**, and a **hash of the previous block**. In this case, the hash is calculated using the _SHA-256_ algorithm:

```py
class Block:
    def __init__(self, transactions: List[Transaction], previous_hash: str):
        self.timestamp = strftime('%Y-%m-%d %H:%M:%S', localtime())
        self.transactions = transactions
        self.previous_hash = previous_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        tx_str = ''.join(str(tx) for tx in self.transactions)
        block_string = f'{self.timestamp}{tx_str}{self.previous_hash}'
        return hashlib.sha256(block_string.encode()).hexdigest()

    def __repr__(self):
        return json.dumps({
            'hash': self.hash,
            'previous_hash': self.previous_hash,
            'transactions': [str(tx) for tx in self.transactions],
            'timestamp': self.timestamp
        }, indent=4)
```

### ⛓️ Blockchain

Finally, we will create a `Blockchain` class to represent the entire blockchain. This class will manage the **list of blocks** and the **pending transactions**. It will also include methods to **add transactions**, **mine new blocks**, and **validate the chain**:

```py
class Blockchain:
    def __init__(self):
        self.chain: List[Block] = [self.create_genesis_block()]
        self.pending_transactions: List[Transaction] = []

    def create_genesis_block(self):
        return Block(transactions=[], previous_hash='0')

    def get_latest_block(self):
        return self.chain[-1]

    def add_transaction(self, transaction: Transaction):
        self.pending_transactions.append(transaction)

    def mine_block(self):
        if not self.pending_transactions:
            return None

        new_block = Block(
            transactions=self.pending_transactions,
            previous_hash=self.get_latest_block().hash
        )
        self.chain.append(new_block)
        self.pending_transactions = []
        return new_block

    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            curr = self.chain[i]
            prev = self.chain[i - 1]
            if curr.hash != curr.calculate_hash():
                return False
            if curr.previous_hash != prev.hash:
                return False
        return True

    def __repr__(self):
        return '\n'.join(str(block) for block in self.chain)
```

---

## 🚀 Let's Play

Now that we have implemented the basic components of a blockchain, let's explore how to use them in practice.

### ⛓️ Creating a Blockchain

We start by creating an instance of the `Blockchain` class:

```py
blockchain = Blockchain()
print(f"Blockchain: {blockchain}")
```

At the beginning, the blockchain contains only the **genesis block**:

```out
Blockchain: {
    "hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "previous_hash": "0",
    "transactions": [],
    "timestamp": "2025-04-20 11:24:45"
}
```

:::info Genesis Block
The **genesis block** is the first block in a blockchain and serves as the foundation of the chain. It is **unique** because it has no previous block, and its `previous_hash` is set to `0`. This block is crucial for establishing the **integrity** and **immutability** of the blockchain.
:::

### 💸 Adding Transactions

Now, let's add a first transaction of `50` units from `Alice` to `Eve` and mine a new block:

```py
blockchain.add_transaction(Transaction('Alice', 'Eve', 50))
mined_block = blockchain.mine_block()
print(f"Blockchain: {blockchain}")
print('\n# -------------------------\n')
print(f"Mined Block 1: {mined_block}")
```

The `mine_block` method creates a new block with the **pending transactions** and adds it to the blockchain. The `previous_hash` of the new block is set to the **hash of the latest block** in the chain:

```out
Blockchain: {
    "hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "previous_hash": "0",
    "transactions": [],
    "timestamp": "2025-04-20 11:24:45"
}
{
    "hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "previous_hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "transactions": [
        "Alice -> Eve: 50"
    ],
    "timestamp": "2025-04-20 11:24:45"
}

# -------------------------

Mined Block 1: {
    "hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "previous_hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "transactions": [
        "Alice -> Eve: 50"
    ],
    "timestamp": "2025-04-20 11:24:45"
}
```

:::info Mining
The process of creating a new block and adding it to the blockchain is called **mining**. In a real-world blockchain, this process involves solving complex **mathematical problems** to validate transactions and secure the network.
:::

---

Next, let's add another transaction of `50` units from `Bob` to `Alice` and mine a second block:

```py
blockchain.add_transaction(Transaction('Bob', 'Alice', 50))
mined_block = blockchain.mine_block()
print(f"Blockchain: {blockchain}")
print('\n# -------------------------\n')
print(f"Mined Block 2: {mined_block}")
```

The second block is created in the **same way** as the first one, with the `previous_hash` set to the hash of the first block:

```out
Blockchain: {
    "hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "previous_hash": "0",
    "transactions": [],
    "timestamp": "2025-04-20 11:24:45"
}
{
    "hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "previous_hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "transactions": [
        "Alice -> Eve: 50"
    ],
    "timestamp": "2025-04-20 11:24:45"
}
{
    "hash": "25eebad25dc8b2e46b9b2329f58080dd9900e0b1db63ff4ff5427806ce50c1e4",
    "previous_hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "transactions": [
        "Bob -> Alice: 50"
    ],
    "timestamp": "2025-04-20 11:24:45"
}

# -------------------------

Mined Block 2: {
    "hash": "25eebad25dc8b2e46b9b2329f58080dd9900e0b1db63ff4ff5427806ce50c1e4",
    "previous_hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "transactions": [
        "Bob -> Alice: 50"
    ],
    "timestamp": "2025-04-20 11:24:45"
}
```

### 🔥 Chain Validation

Now, let's explore what happens if someone tries to **tamper** with the blockchain:

```py
print(f"Validity: {blockchain.is_chain_valid()}")
print('\n# -------------------------\n')

# -------------------------

blockchain.chain[1].transactions[0].amount = 1000
print(f"Tampered Block 1: {blockchain.chain[1]}")

# -------------------------

print('\n# -------------------------\n')
print(f"Validity: {blockchain.is_chain_valid()}")
```

:::danger Tampering
Eve is trying to cheat by changing the amount of the first transaction from `50` to `1000`.
:::

The `is_chain_valid` method will check if the hash of the tampered block **matches** the calculated hash. If it doesn't, it will return `False`, indicating that the chain is invalid:

```out
Validity: True

# -------------------------

Tampered Block 1: {
    "hash": "8c63bd4682ed1c53c365ebc9878987618eb45c69b9c1941ae3cd69bee1fdd389",
    "previous_hash": "3f1af6b8c2124cf3063dc68ee0f4889c4c088d3604b6cf42ab50bdd685e8f1b0",
    "transactions": [
        "Alice -> Eve: 1000"
    ],
    "timestamp": "2025-04-20 11:24:45"
}

# -------------------------

Validity: False
```

This last example demonstrates how the blockchain's integrity is maintained through **cryptographic hashing**. If any block in the chain is tampered with, the hash of that block will change, causing the `is_chain_valid` method to return `False`. This ensures that the blockchain remains secure and **tamper-proof**.

:::tip Consensus
In a real-world blockchain, the **consensus mechanism** (like _Proof of Work_ or _Proof of Stake_) is used to ensure that all nodes in the network **agree on the state** of the blockchain. This prevents malicious actors from tampering with the chain and ensures that all transactions are valid.
:::

---

## 🎯 Conclusion

In this playground, we have implemented a simple blockchain in Python. We created classes for **transactions**, **blocks**, and the **blockchain** itself. We also demonstrated how to add transactions, mine new blocks, and validate the chain.
